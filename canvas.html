<!DOCTYPE html>
<html lang="en">
<body>

<canvas id="myCanvas" width="700" height="400" style="border:1px solid #d3d3d3;">
</canvas>

<script>
    let canvas = document.getElementById('myCanvas');
    let ctx = canvas.getContext('2d');

    let gridSize = 4;
    let cellSize = canvas.height / gridSize;
    let dragObject = null;

    let objects = [
        {
            id: 0,
            x: 420,
            y: 50,
            w: cellSize * 3,
            h: cellSize,
            color: 'green',
            originX: 420,
            originY: 50,
            gridPosX: null,
            gridPosY: null,
            isInGrid: false
        },
        {
            id: 1,
            x: 420,
            y: 250,
            w: cellSize,
            h: cellSize,
            color: 'red',
            originX: 420,
            originY: 250,
            gridPosX: null,
            gridPosY: null,
            isInGrid: false
        },
        {
            id: 2,
            x: 520,
            y: 150,
            w: cellSize,
            h: cellSize * 2,
            color: 'blue',
            originX: 520,
            originY: 150,
            gridPosX: null,
            gridPosY: null,
            isInGrid: false
        }
    ];

    let grid = Array(gridSize).fill(undefined).map(() => Array(gridSize).fill({
        color: 'white',
        originX: null,
        originY: null,
        id: null,
        w: null,
        h: null
    }));

    let gridCopy = null;

    function drawGrid() {
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                if (dragObject && dragObject.isInGrid && i * cellSize === dragObject.x && j * cellSize === dragObject.y) {
                    continue;
                }
                ctx.fillStyle = grid[i][j].color;
                ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                ctx.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
            }
        }
    }

    function drawObjects() {
        objects.forEach(obj => {
            ctx.fillStyle = obj.color;
            ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
        });
    }

    function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawGrid();
        drawObjects();

        if (dragObject) {
            ctx.fillStyle = dragObject.color;
            ctx.fillRect(dragObject.x, dragObject.y, dragObject.w, dragObject.h);
        }
    }

    redraw();

    canvas.addEventListener('mousedown', function (event) {
        let rect = canvas.getBoundingClientRect();
        let x = event.clientX - rect.left;
        let y = event.clientY - rect.top;

        let i = Math.floor(x / cellSize);
        let j = Math.floor(y / cellSize);

        if (i < gridSize && j < gridSize && grid[i][j].id !== null) {
            dragObject = {
                id: grid[i][j].id,
                x: i * cellSize,
                y: j * cellSize,
                w: grid[i][j].w,
                h: grid[i][j].h,
                color: grid[i][j].color,
                originX: grid[i][j].originX,
                originY: grid[i][j].originY,
                gridPosX: i,
                gridPosY: j,
                isInGrid: true
            };

            gridCopy = JSON.parse(JSON.stringify(grid));

            for (let di = 0; di < grid.length; di++) {
                for (let dj = 0; dj < grid[di].length; dj++) {
                    if (grid[di][dj].id === dragObject.id) {
                        grid[di][dj] = {color: 'white', originX: null, originY: null, id: null, w: null, h: null};
                    }
                }
            }
        } else {
            dragObject = objects.find(obj => x > obj.x && x < obj.x + obj.w && y > obj.y && y < obj.y + obj.h);
        }
    });

    canvas.addEventListener('contextmenu', function(event) {
        event.preventDefault();
        canvas.focus();

        //todo fixen
    });

    canvas.addEventListener('mouseleave', function(event) {
       reset()
    });

    function reset() {
        if (dragObject) {
            if (!dragObject.isInGrid) {
                objects = objects.filter(obj => obj !== dragObject);

                objects.push({
                    id: dragObject.id,
                    x: dragObject.originX,
                    y: dragObject.originY,
                    w: dragObject.w,
                    h: dragObject.h,
                    color: dragObject.color,
                    originX: dragObject.originX,
                    originY: dragObject.originY,
                    gridPosX: null,
                    gridPosY: null,
                    isInGrid: false
                });
            } else if (dragObject.isInGrid) {
                grid = gridCopy;
            }

            dragObject = null;
            redraw();
        }
    }

    canvas.addEventListener('mousemove', function (event) {
        if (dragObject) {
            let rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;

            dragObject.x = x - dragObject.w / 2;
            dragObject.y = y - dragObject.h / 2;

            redraw();
        }
    });

    canvas.addEventListener('mouseup', function (event) {
        if (dragObject) {
            let x = (event.clientX - dragObject.w / 2) + (cellSize / 2);
            let y = (event.clientY - dragObject.h / 2) + (cellSize / 2);

            let i = Math.floor(x / cellSize);
            let j = Math.floor(y / cellSize);

            if (i < gridSize && j < gridSize && i >= 0 && j >= 0) {
                let canMoveToGrid = true;
                for (let di = 0; di < dragObject.w / cellSize; di++) {
                    for (let dj = 0; dj < dragObject.h / cellSize; dj++) {
                        if (i + di >= gridSize || j + dj >= gridSize || grid[i + di][j + dj].id !== null) {
                            canMoveToGrid = false;
                            break;
                        }
                    }
                    if (!canMoveToGrid) {
                        break;
                    }
                }

                if (canMoveToGrid) {
                    for (let di = 0; di < dragObject.w / cellSize; di++) {
                        for (let dj = 0; dj < dragObject.h / cellSize; dj++) {
                            grid[i + di][j + dj] = {
                                color: dragObject.color,
                                originX: dragObject.originX,
                                originY: dragObject.originY,
                                id: dragObject.id,
                                w: dragObject.w,
                                h: dragObject.h
                            };
                        }
                    }
                    objects = objects.filter(obj => obj !== dragObject);
                } else {
                    if (!dragObject.isInGrid) {
                        objects = objects.filter(obj => obj !== dragObject);

                        objects.push({
                            id: dragObject.id,
                            x: dragObject.originX,
                            y: dragObject.originY,
                            w: dragObject.w,
                            h: dragObject.h,
                            color: dragObject.color,
                            originX: dragObject.originX,
                            originY: dragObject.originY,
                            gridPosX: null,
                            gridPosY: null,
                            isInGrid: false
                        });
                    } else if (dragObject.isInGrid) {
                        grid = gridCopy;
                    }
                }
            } else {
                objects = objects.filter(obj => obj !== dragObject);

                objects.push({
                    id: dragObject.id,
                    x: dragObject.originX,
                    y: dragObject.originY,
                    w: dragObject.w,
                    h: dragObject.h,
                    color: dragObject.color,
                    originX: dragObject.originX,
                    originY: dragObject.originY,
                    gridPosY: null,
                    gridPosX: null,
                    isInGrid: false
                });
            }

            dragObject = null;
            redraw();
        }
    });
</script>

</body>
</html>
